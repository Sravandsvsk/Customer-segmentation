# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1emSmzQOjP-6br79FnyAx6I1fB1wS7Su1
"""
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.cluster import KMeans, DBSCAN, AgglomerativeClustering
from sklearn.metrics import silhouette_score
from scipy.cluster.hierarchy import dendrogram, linkage

# Load dataset
@st.cache_data
def load_data():
    data = pd.read_excel('marketing_campaign1.xlsx')
    return data.copy()

data = load_data()

# Preprocess non-numeric columns for clustering (encoding if needed)
@st.cache_data
def preprocess_data(data):
    processed_data = data.copy()
    # Encode non-numeric columns
    label_encoders = {}
    for column in processed_data.select_dtypes(include=['object']).columns:
        le = LabelEncoder()
        processed_data[column] = le.fit_transform(processed_data[column].astype(str))
        label_encoders[column] = le
    return processed_data, label_encoders

processed_data, label_encoders = preprocess_data(data)

# Title
st.title("Customer Personality Analysis and Segmentation")
st.markdown("Analyze customer data to uncover patterns and create actionable insights.")

# Tabs for EDA and Clustering
tab1, tab2 = st.tabs(["ðŸ“Š EDA", "ðŸ”— Clustering"])

# EDA Tab
with tab1:
    st.subheader("Exploratory Data Analysis (EDA)")
    st.markdown("Explore the dataset and visualize key trends.")

    # Display raw data
    if st.checkbox("Show Raw Data"):
        st.write(data)

    # Age Distribution
    if st.checkbox("Show Age Distribution"):
        data['Age'] = 2025 - data['Year_Birth']
        fig, ax = plt.subplots(figsize=(8, 5))
        ax.hist(data['Age'], bins=20, color='skyblue', edgecolor='black')
        ax.set_title("Age Distribution of Customers")
        ax.set_xlabel("Age")
        ax.set_ylabel("Frequency")
        st.pyplot(fig)

    # Spending Distribution
    spending_columns = [
        'MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts',
        'MntSweetProducts', 'MntGoldProds'
    ]
    if st.checkbox("Show Spending Distribution"):
        total_spending = data[spending_columns].sum()
        fig, ax = plt.subplots(figsize=(8, 5))
        total_spending.plot(kind='bar', ax=ax, color='orange', edgecolor='black')
        ax.set_title("Total Spending on Product Categories")
        ax.set_xlabel("Product Category")
        ax.set_ylabel("Total Spending")
        st.pyplot(fig)

    # Income Distribution
    if st.checkbox("Show Income Distribution"):
        fig, ax = plt.subplots(figsize=(8, 5))
        ax.hist(data['Income'], bins=20, color='green', edgecolor='black')
        ax.set_title("Income Distribution of Customers")
        ax.set_xlabel("Income")
        ax.set_ylabel("Frequency")
        st.pyplot(fig)

    # Marital Status Distribution
    if st.checkbox("Show Marital Status Distribution"):
        fig, ax = plt.subplots(figsize=(8, 5))
        data['Marital_Status'].value_counts().plot(kind='bar', ax=ax, color='purple', edgecolor='black')
        ax.set_title("Marital Status Distribution")
        ax.set_xlabel("Marital Status")
        ax.set_ylabel("Frequency")
        st.pyplot(fig)

    # Education Level Distribution
    if st.checkbox("Show Education Level Distribution"):
        fig, ax = plt.subplots(figsize=(8, 5))
        data['Education'].value_counts().plot(kind='bar', ax=ax, color='teal', edgecolor='black')
        ax.set_title("Education Level Distribution")
        ax.set_xlabel("Education Level")
        ax.set_ylabel("Frequency")
        st.pyplot(fig)


    # Correlation Heatmap
    if st.checkbox("Show Correlation Heatmap"):
        # Select only relevant numeric columns
        relevant_columns = [
            'Income', 'Recency', 'MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts',
            'MntSweetProducts', 'MntGoldProds', 'NumDealsPurchases', 'NumWebPurchases',
            'NumCatalogPurchases', 'NumStorePurchases', 'NumWebVisitsMonth', 'Response'
        ]
        numeric_data = data[relevant_columns].dropna()

        if numeric_data.empty:
            st.error("No numeric data available for correlation.")
        else:
            # Calculate correlation matrix
            corr = numeric_data.corr()
            
            # Plot heatmap
            fig, ax = plt.subplots(figsize=(12, 10))  # Increase figure size for readability
            sns.heatmap(corr, annot=True, fmt=".2f", cmap="RdBu", cbar=True, ax=ax, vmin=-1, vmax=1)
            ax.set_title("Correlation Heatmap (Filtered)")
            st.pyplot(fig)

# Clustering Tab
with tab2:
    st.subheader("Clustering Analysis")
    st.markdown("Group customers based on similar traits and behaviors.")

    # Feature Selection
    selected_features = st.multiselect(
        "Select Features for Clustering",
        options=processed_data.columns.tolist(),
        default=['MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts'],
        help="Choose features for clustering."
    )

    if selected_features:
        # Filter selected numeric features
        numeric_features = processed_data[selected_features]

        if numeric_features.empty:
            st.error("Please select at least one numeric feature for clustering.")
        else:
            # Handle missing values by filling them with the column mean
            numeric_features = numeric_features.fillna(numeric_features.mean())

            # Standardize the data
            scaler = StandardScaler()
            scaled_features = scaler.fit_transform(numeric_features)

            # Choose clustering algorithm
            clustering_method = st.radio(
                "Select Clustering Algorithm",
                ["KMeans", "DBSCAN", "Hierarchical Agglomerative Clustering"],
                help="Choose the clustering method you'd like to apply."
            )

            if clustering_method == "KMeans":
                n_clusters = st.slider("Number of Clusters", 2, 10, 3)
                kmeans = KMeans(n_clusters=n_clusters, random_state=42)
                processed_data['Cluster'] = kmeans.fit_predict(scaled_features)
                st.success(f"KMeans clustering completed with {n_clusters} clusters.")

                # Elbow Plot for KMeans
                distortions = []
                K = range(1, 11)
                for k in K:
                    kmeans_temp = KMeans(n_clusters=k, random_state=42)
                    kmeans_temp.fit(scaled_features)
                    distortions.append(kmeans_temp.inertia_)

                fig, ax = plt.subplots(figsize=(8, 5))
                ax.plot(K, distortions, marker='o')
                ax.set_title("Elbow Method for Optimal Clusters")
                ax.set_xlabel("Number of Clusters")
                ax.set_ylabel("Distortion")
                st.pyplot(fig)

                # Cluster Centers Visualization
                st.write("Cluster Centers:", kmeans.cluster_centers_)

            elif clustering_method == "DBSCAN":
                eps = st.slider("Epsilon (eps)", 0.1, 5.0, 0.5, step=0.1)
                min_samples = st.slider("Minimum Samples", 1, 10, 5)
                dbscan = DBSCAN(eps=eps, min_samples=min_samples)
                try:
                    processed_data['Cluster'] = dbscan.fit_predict(scaled_features)
                    st.success("DBSCAN clustering completed.")
                except ValueError as e:
                    st.error(f"DBSCAN failed: {str(e)}")

            elif clustering_method == "Hierarchical Agglomerative Clustering":
                n_clusters = st.slider("Number of Clusters", 2, 10, 3)
                linkage_type = st.selectbox("Linkage Type", ["ward", "complete", "average", "single"])
                agglo = AgglomerativeClustering(n_clusters=n_clusters, linkage=linkage_type)
                processed_data['Cluster'] = agglo.fit_predict(scaled_features)
                st.success(f"Hierarchical Agglomerative Clustering completed with {n_clusters} clusters.")

                # Dendrogram for Hierarchical Clustering
                linked = linkage(scaled_features, method=linkage_type)
                fig, ax = plt.subplots(figsize=(10, 7))
                dendrogram(linked, truncate_mode='level', p=5)
                ax.set_title("Hierarchical Clustering Dendrogram")
                st.pyplot(fig)

            # Evaluate Best Clustering Method
            st.markdown("### Best Clustering Method Results")
            if clustering_method == "KMeans":
                silhouette_avg = silhouette_score(scaled_features, processed_data['Cluster'])
                st.write(f"Silhouette Score for KMeans: {silhouette_avg:.2f} (Higher is better).")
                st.write("KMeans is often the best choice for datasets with spherical, evenly distributed clusters.")

            elif clustering_method == "DBSCAN":
                silhouette_avg = silhouette_score(scaled_features, processed_data['Cluster'])
                st.write(f"Silhouette Score for DBSCAN: {silhouette_avg:.2f} (Higher is better).")
                st.write("DBSCAN is ideal for datasets with noise and clusters of varying densities.")

            elif clustering_method == "Hierarchical Agglomerative Clustering":
                silhouette_avg = silhouette_score(scaled_features, processed_data['Cluster'])
                st.write(f"Silhouette Score for Agglomerative Clustering: {silhouette_avg:.2f} (Higher is better).")
                st.write("Hierarchical clustering is useful for understanding cluster hierarchies in smaller datasets.")

            # Visualize Clusters
            if "Cluster" in processed_data.columns:
                st.markdown("### Cluster Visualization")
                fig, ax = plt.subplots(figsize=(8, 5))
                plt.scatter(scaled_features[:, 0], scaled_features[:, 1], c=processed_data['Cluster'], cmap='viridis', s=50, alpha=0.7)
                plt.title(f"Clusters Visualization ({clustering_method})")
                plt.xlabel("Feature 1")
                plt.ylabel("Feature 2")
                st.pyplot(fig)
